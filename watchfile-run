#!/usr/bin/perl -w

# Fre Sep  7 11:43:44 CEST 2007
(my $email='pflanze%gmx,ch')=~ tr/%,/@./;

use strict;

my $sleeptime= 0.1; # how long to sleep between change verifications
my @excludes = qw(./.git );  # sigh, must be paths! Pretty useless.

$0=~ /(.*?)([^\/]+)\z/s or die "?";
my ($mydir, $myname)=($1,$2);
sub usage {
    print STDERR map{"$_\n"} @_ if @_;
    print "$myname cmd filename_regex dir(s)

  Watch <dir(s)> for files whose basename match <filename_regex> for
  changes, if a change happens, run cmd (which is run using perl's
  system call thus can be shell code).

  Options:
   -a  also run before waiting
   -t  show time stamp before running cmd

  Also see: 'C' and 'lambda' for building 'cmd' (but can use shell,
  too)

  (Christian Jaeger <$email>)
";
exit (@_ ? 1 : 0);
}

my @args;
my $DEBUG=0;
our $verbose;
our $opt_a;
our $opt_t;
for (my $i=0; $i<=$#ARGV; $i++) {
    local $_=$ARGV[$i];
    if (/^--?h(elp)?$/) {
    	usage
    } elsif ($_ eq '--') {
    	push @args, @ARGV[$i+1..$#ARGV];
    	last;
    } elsif (/^--?d(ebug)?$/) {
	$DEBUG=1;
    } elsif (/^--?a$/) {
	$opt_a=1;
    } elsif (/^--?t$/) {
	$opt_t=1;
    } elsif (/^--?v(erbose)?$/) {
	$verbose=1;
    } elsif (/^-./) {
    	usage("Unknown option '$_'\n");
    } else {
    	push @args, $_
    }
}
usage unless @args >= 3;

use Time::HiRes 'sleep';
use File::ChangeNotify;
use Chj::xperlfunc;# 'xstat';
use Chj::Unix::Exitcode 'exitcode';

my ($cmd, $regex, @dirs)= @args;

$|++;

sub runit {
    if ($opt_t) {
        print "--".localtime()."-------------------------------------\n";
    }
    xsystem $cmd;
    if ($opt_t) {
        print(("-"x63)."\r");
    }
}

runit
    if $opt_a;

sub any_changes {
    my ($path2maybe_stat)= @_;
    my $changed = 0;
    for my $path (sort keys %$path2maybe_stat) {
        my $olds= $path2maybe_stat->{$path};
        my $s= Xlstat $path;
        if (not defined $olds and not defined $s) {
            # continue
        } else {
            if (defined $olds and defined $s) {
                if ($s->equal($olds)) {
                    # continue
                } else {
                    $path2maybe_stat->{$path} = $s;
                    $changed = 1;
                }
            } else {
                $path2maybe_stat->{$path} = $s;
                $changed = 1;
            }
        }
    }
    warn "any_changes => $changed" if $verbose;
    $changed
}

my $watcher =
    File::ChangeNotify->instantiate_watcher(
        directories => \@dirs,
        # filter      => qr/./,
        #  no, do own filtering (debuggable, and can do filename patterns)
        exclude     => \@excludes,
    );

# Need to carry $path2maybe_stat over since $watcher returns more
# events that came before our cmd finishes (or we do our own polling),
# we need to ignore those:
my $path2maybe_stat;

while (my @_events = $watcher->wait_for_events) {
    if ($verbose) {
        warn "\nchanges reported on: ".join(", ", map { $_->path } @_events);
    }
    my @events = grep {
        my $n = $_->path;
        $n=~ s{^.*/}{};
        $n=~ /$regex/
    } @_events;
    next unless @events;
    if ($verbose) {
        warn "    after filtering: ".join(", ", map { $_->path } @events);
    }

    if ($path2maybe_stat) {
        if (not any_changes($path2maybe_stat)) {
            warn "   ignoring duplicate report" if $verbose;
            next;
        }
    }
    
    $path2maybe_stat = +{
        map {
            $_=> scalar Xlstat $_
        } map {
            # $_->type eq "delete" ? () : $_->path
            # no, verify delete events, too
            $_->path
        } @events
    };
    # Wait till filehandles are closed and don't change anymore: (no
    # way to get that from File::ChangeNotify)
    do {
        sleep $sleeptime;
    } while (any_changes($path2maybe_stat));
    do {
        runit;
        sleep $sleeptime;
    } while (any_changes($path2maybe_stat));
}
