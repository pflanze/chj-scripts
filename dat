#!/usr/bin/env perl

my $copyright= <<'COPYRIGHT';
# Copyright 2022 by Christian Jaeger <ch@christianjaeger.ch>
# Published under the same terms as perl itself
COPYRIGHT

use strict;
use utf8;
use warnings;
use warnings FATAL => 'uninitialized';
use experimental 'signatures';

# use FP::Repl::Trap; #

my ($email_full)= $copyright=~ / by ([^\n]*)/s;

my ($mydir, $myname);
BEGIN {
    $0=~ /(.*?)([^\/]+)\z/s or die "?";
    ($mydir, $myname)=($1,$2);
}

package dat::AbsoluteTime {
    sub unixtime($self) {
        $self->{unixtime}
    }
    #sub is_absolute($self) { 1 }
    sub add_onto($self, $other) {
        die "can't add an absolute time on top of relative ones: $self->{unixtime}"
    }
    sub add_offset_seconds($self, $offset_seconds) {
        bless { unixtime => $self->{unixtime} + $offset_seconds }, ref($self)
    }
}

sub AbsoluteTime($unixtime) {
    bless { unixtime => $unixtime }, "dat::AbsoluteTime"
}

package dat::TimeOffset {
    sub unixtime($self) {
        time + $self->{offset_seconds}
    }
    #sub is_absolute($self) { 0 }
    sub add_onto($self, $other) {
        $other->add_offset_seconds($self->{offset_seconds})
    }
    sub add_offset_seconds($self, $offset_seconds) {
        bless { offset_seconds => $self->{offset_seconds} + $offset_seconds }, ref($self)
    }
}

sub TimeOffset($offset_seconds) {
    bless { offset_seconds => $offset_seconds }, "dat::TimeOffset"
}


sub parse_timespec($str) {
    if ($str=~ /^(\d{10,11})$/s) {
        AbsoluteTime($1)
    } elsif (my ($sign, $digits, $unit) = $str=~ /^([+-])(\d+)([wdhms]|days?|hours?|minutes?|seconds?|mins?|secs?|weeks?)$/s) {
        my $multiplier = +{
            # can't handle months? that way
            s=> 1, m=> 60, h=> 60 * 60, d=> 24 * 60 * 60, w=> 7 * 24 * 60 * 60
        }->{substr $unit, 0, 1} or die "bug";
        my $signage = +{ "-"=> -1, "+"=> 1 }->{$sign} or die "bug";
        TimeOffset($signage * $digits * $multiplier)
    } else {
        usage("invalid time argument '$str', must be unixtime or +/- n days|hours|minutes|seconds|weeks ".
              "or shorter forms of the latter")
    }
}


sub usage {
    my $out = @_ ? *STDERR{IO} : *STDOUT{IO};
    print $out map{"$_\n"} @_ if @_;
    print $out "$myname [options] [timespec...]

  Print the current time, or an absolute time (in unixtime) or/and any
  number of time offsets (+/- n secs/mins/hours/days/weeks) if given,
  as YYYY-MM-DD_HHMM in the current time zone (lexical sorting == time
  sorting, except when ambiguous...).

  Set TZ=UTC to get unambiguous output.

  Options:
     --day              show day only
     --sec | --seconds  show seconds as well (-s currently works as well)
     --tz               show time zone
     --wday             show weekday (default)
     --no-wday          do not show weekday
     --week             show week number

  Also see: dat, date_

  ($email_full)
";
exit (@_ ? 1 : 0);
}

my $opt_sec = 0;
my $opt_day = 0;
my $opt_tz;
my $opt_wday = 1;
my $opt_week;

my @timespecs;

while (@ARGV) {
    my $v = shift @ARGV;
    if ($v eq "-s" or $v eq "--sec" or $v eq "--seconds") {
        $opt_sec = 1;
        $opt_day = 0;
    }
    elsif ($v eq "--day") {
        $opt_sec = 0;
        $opt_day = 1;
    }
    elsif ($v eq "--wday") {
        $opt_wday = 1;
    }
    elsif ($v eq "--no-wday") {
        $opt_wday = 0;
    }
    elsif ($v eq "--tz") {
        $opt_tz = 1;
    }
    elsif ($v eq "--week") {
        $opt_week = 1;
    }
    elsif ($v eq "-h" or $v eq "--help") {
        usage
    }
    else {
        push @timespecs, parse_timespec($v);
    }
}

usage if @ARGV; # needed? see algo above

my $t = (shift @timespecs) // AbsoluteTime(time);
for my $timespec (@timespecs) {
    $t = $timespec->add_onto($t);
}

my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime($t->unixtime)
    or die "invalid time";

sub weekday {
    my ($num) = @_;
    (qw(Sun Mon Tue Wed Thu Fri Sat))[$num] // die "invalid wday '$num'"
}

use feature 'state';
sub dt {
    require DateTime;
    state $dt = DateTime->from_epoch(epoch=> $t->unixtime)
}
sub tz {
    require DateTime::TimeZone;
    state $tz = DateTime::TimeZone->new(name=> "local")
}

my $MIN = $opt_day ? '' : '_%02d%02d';
my $SEC = $opt_sec ? '%02d' : '';
my $WDAY = $opt_wday ? '_'.weekday($wday) : '';
my $TZ = $opt_tz ? do {
    "_" . tz->short_name_for_datetime( dt )
} : '';
my $WEEK = $opt_week ? "-W".(dt->week)[1] : '';

printf("%04d-%02d-%02d$MIN$SEC$WDAY$WEEK$TZ\n",
       $year+1900, $mon+1, $mday,
       ($opt_day ? () :
        ($hour, $min, ($opt_sec ? $sec : ()))))
    or die "stdout: $!";

#use FP::Repl; repl;
