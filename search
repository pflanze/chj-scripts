#!/usr/bin/perl -w

# Sun 14 Mar 23:46:14 GMT 2021
(my $email='ch%christianjaeger,ch')=~ tr/%,/@./;

use strict;
use warnings FATAL => 'uninitialized';
use experimental 'signatures';

#use FP::Repl::Trap;#
use Chj::Backtrace;#

$0=~ /(.*?)([^\/]+)\z/s or die "?";
my ($mydir, $myname)=($1,$2);
sub usage {
    print STDERR map{"$_\n"} @_ if @_;
    print "$myname regex...

  In the current Git checkout, searches both paths, as well as file
  contents, for all of the given perl style regexes. Shows those paths
  that can be found (either via path or content) for all regexes
  (intersection).

  Options:

     -i | --insensitive   regex is matched insensitively
     --sort-alpha         sort alphabetically instead of by mtime

  (Christian Jaeger <$email>)
";
exit (@_ ? 1 : 0);
}

use Getopt::Long;
our $verbose=0;
#our $opt_dry;
my $opt_i;
my $opt_sort_alpha;
GetOptions("verbose"=> \$verbose,
	   "help"=> sub{usage},
           "insensitive"=> \$opt_i,
           "sort-alpha"=> \$opt_sort_alpha,
	   #"dry-run"=> \$opt_dry,
	   ) or exit 1;
usage unless @ARGV;

#[[ use Chj::Parallel_for_each qw(Parallel_for_each);
# no, need results, and   hu not even in fperl there's sth  ? ?

use Chj::xperlfunc;
use Chj::xpipe;
use Chj::Linux::numcpus;

our $Parallel_n= numcpus; # number of cpus to use

use POSIX ();

package parallel_map::Exception {
    use FP::Struct ['string']
        => qw(FP::Struct::Equal FP::Struct::Show);
    _END_
}

# Return types can only be strings for now!
sub parallel_map($vec, $proc) {
    my @shifts= (0..($Parallel_n-1));
    my $len= @$vec;
    my @child= map {
	my $shift=$_;
        my ($piperead, $pipewrite) = xpipe;
	if (my $pid= xfork) {
            $pipewrite->xclose;
	    [ $pid, $piperead ]
	} else {
            $piperead->xclose;
	    for (my $i= $shift; $i< $len; $i+= $Parallel_n) {
                my $res;
		if (eval {
                    $res = $proc->($$vec[$i]);
                    1
                    }) {
                    $res=~ s/\\/\\\\/sg; 
                    $res=~ s/\0/\\0/sg;
                    $pipewrite->xprint("R$res\0");
                } else {
                    my $e = "$@";
                    $e=~ s/\\/\\\\/sg; 
                    $e=~ s/\0/\\0/sg;
                    $pipewrite->xprint("E$e\0");
                }
	    }
            $pipewrite->xclose;
	    POSIX::_exit(0);
	}
    } @shifts;

    # have to bring the results into the right order again (kinda
    # sigh):
    my @ress =
        map {
            my ($pid, $piperead) = @$_;
            xxwaitpid $pid, 0;
            my @ress= map {
                my $type = substr $_, 0, 1;
                my $val = substr $_, 1;
                if ($type eq "E") {
                    parallel_map::Exception->new($val)
                } elsif ($type eq "R") {
                    # XX utf-8 ! todo
                    $val
                } else {
                    die "BUG"
                }
            } $piperead->xreadline0_chop;
            $piperead->xclose;
            \@ress
    } @child;
    my @res;
    for (my $i= 0; $i< $len; $i+= 1) {
        for (my $shift = 0; $shift < $Parallel_n; $shift++) {
            my $slice = $ress[$shift];
            last unless $i < @$slice;
            push @res, $slice->[$i];
        }
    }
    \@res
}

sub parallel_filter($vec, $proc) {
    my $bools_and_exns = parallel_map($vec, $proc);
    my @res;
    for (my $i = 0; $i < @$vec; $i++) {
        my $be= $bools_and_exns->[$i];
        if (ref $be) {
            die $be
        }
        push @res, $vec->[$i] if $be;
    }
    \@res
}

#]]


use Encode;
use Chj::Git::Functions qw(git_ls_files);
use FP::HashSet ":all";
use Chj::xperlfunc qw(xprintln Xlstat xgetfile_utf8);
# why use both array and purearray? XX hashset should be adapted.
use FP::Array ":all";
use FP::PureArray ":all";
use FP::Predicates qw(complement);

sub hash_key_filter($hash, $pred) {
    # only keep k=>v entries for which $pred->($k) is true
    +{
        map {
            $pred->($_) ? ($_ => $hash->{$_}) : ()
        } keys %$hash
    }
}
# ^ XX hashset_key_filter ?

# Hash to array of key-value tuples
sub hash_kvs_unsorted($hash) {
    [
     map {
         [ $_ => $hash->{$_} ]
     }
     keys %$hash
    ]
}

# Array of key-value tuples to hash
sub kvs_to_hash($kvs) {
    +{
        map {
            $_->[0] => $_->[1]
        }
        @$kvs
    }
}

sub suffix ($path) {
    if (my ($suffix) = $path=~ m{\.(\w+)\z}) {
        $suffix
    } else {
        ""
    }
}

my $ignored_suffix= +{
    map { $_=> 1 }
    qw(pdf bz2 zip gz rz png jpeg jpg gif ods odt doc docx xls)
};
sub ignore_suffix($suff) {
    $ignored_suffix->{lc($suff)}
}
sub ignore($path) {
    $path=~ m{(?:^|/)\.METADATA-v2/} or ignore_suffix(suffix $path)
}

# path => stat
my $fileset= do {
    my $fs= array_to_purearray scalar git_ls_files;
    my $pss=
        $fs
        ->filter(complement \&ignore)
        ->map(
            sub ($path) {
                if (my $s= Xlstat $path) {
                    [$path, $s]
                } else {
                    undef
                }
            })
        ->filter(
            sub ($ps) {
                return 0 unless defined $ps;
                my ($path, $stat)= @$ps;
                not $stat->is_link
            });
    my $filter= sub ($pred) {
        $pss
            ->filter(
            sub ($ps) {
                my ($path, $stat)= @$ps;
                $pred->($stat->is_dir)
            })
    };
    $filter->(sub ($isdir) { $isdir })->for_each(
        sub ($ps) {
            my $p = $ps->[0];
            xprintln "NOTE: ignoring sub-repository: $p";
        });
    my %s;
    $filter->(sub ($isdir) { not $isdir })->for_each(
        sub ($ps) {
            my ($p, $s)= @$ps;
            $s{$p} = $s;
        });
    \%s
};

for my $regex_raw (@ARGV) {
    my $regex = Encode::decode("UTF-8", $regex_raw, Encode::FB_CROAK);
    my $re= $opt_i ? qr/$regex/i : qr/$regex/;

    my $fileset2 = hash_key_filter $fileset, sub ($path) {
        $path =~ m/$re/
    };

    # Might there be more paths to consider, via their contents?
    my $tocheckset= hashset_difference $fileset, $fileset2;
    # We promised Perl style regexes, deliver on that:
    my $morefiles=
        kvs_to_hash
        parallel_filter(
            hash_kvs_unsorted($tocheckset),
            sub ($path_stat) {
                my $path = $path_stat->[0];
                my $res;
                eval {
                    my $cnt= xgetfile_utf8 $path;
                    $res= $cnt=~ /$re/;
                    1
                } ? $res : do {
                    if ($@ =~ /ill-formed UTF-8/) {
                        warn "$myname: ignoring file in non-utf8 encoding: '$path'\n";
                    } else {
                        warn "$myname: ignoring file with error: '$path': $@";
                    }
                    0
                }
            });
    $fileset = hashset_union $fileset2, $morefiles;
}

# always sort alphabetically, first (for stable sort order for entries
# with identical mtime)
my @k = hashset_keys $fileset;

if (! $opt_sort_alpha) {
    @k = sort { $fileset->{$a}->mtime <=> $fileset->{$b}->mtime } @k;
}

for my $path (@k) {
    xprintln $path;
}

