#!/usr/bin/perl -w

use strict;

our $arithmatch= qr{^[\d.()+\-*/\s]+\z};
# ^wow is not parsed at that point (or unparsing is not done from the
# parsed tree): mentioning some char multiple times is carried over to
# the printing.

$0=~ /(.*?)([^\/]+)\z/s or die "?";
my ($mydir, $myname)=($1,$2);
sub usage {
    print STDERR map{"$_\n"} @_ if @_;
    print "$myname [seconds-since-epoch]

  Print localtime

  seconds-since-epoch may be an arithmetic expression matching
   $arithmatch

  When given no argument, filters stdin to stdout, replacing the number in the
  first column with the localtime string.

  Options:

   --keep   print the unixtime column, too

";
exit (@_ ? 1 : 0);
}

use Getopt::Long;
our $verbose=0;
our $opt_keep;
GetOptions("verbose"=> \$verbose,
	   "help"=> sub{usage},
           "keep"=> \$opt_keep,
	   ) or exit 1;

sub one {
    my ($seconds_since_epoch)=@_;

    $seconds_since_epoch=~ /$arithmatch/
      or die "not a number or arithmetic expression: '$seconds_since_epoch'";

    my $rv= eval $seconds_since_epoch;
    die "$myname: $@" if $@;

    print localtime($rv)."\n"
      or die $!;
}

sub many {
    my ($in)=@_;
    while (<$in>) {
	s/^(\d{9,10})\b/localtime($1)/e;
	print or die $!;
    }
}

sub many_keep {
    my ($in)=@_;
    while (<$in>) {
	if (my ($t, $subt) = m/^(\d{9,10})(\.\d+|)\b/) {
            print localtime($t)."$subt\t", $_ or die $!;
        } else {
            print or die $!;
        }
    }
}

if (@ARGV == 1) {
    my ($arg) = @ARGV;
    one $arg
} elsif (@ARGV) {
    usage "too many arguments" # well is ignored
} else {
    if ($opt_keep) {
        many_keep *STDIN{IO}
    } else {
        many *STDIN{IO}
    }
}
