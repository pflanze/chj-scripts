#!/usr/bin/env perl

my $copyright= <<'COPYRIGHT';
# Copyright 2022 by Christian Jaeger <ch@christianjaeger.ch>
# Published under the same terms as perl itself
COPYRIGHT

use strict;
use utf8;
use warnings;
use warnings FATAL => 'uninitialized';
#use experimental 'signatures';

# use FP::Repl::Trap; #

my ($email_full)= $copyright=~ / by ([^\n]*)/s;

my ($mydir, $myname);
BEGIN {
    $0=~ /(.*?)([^\/]+)\z/s or die "?";
    ($mydir, $myname)=($1,$2);
}

sub usage {
    my $out = @_ ? *STDERR{IO} : *STDOUT{IO};
    print $out map{"$_\n"} @_ if @_;
    print $out "$myname [options] [unixtime]

  Print the current time, or unixtime if given, as YYYY-MM-DD_HHMM in
  the current time zone (lexical sorting == time sorting, except when
  ambiguous...).

  Set TZ=UTC to get unambiguous output.

  Options:
     --day              show day only
     --sec | --seconds  show seconds as well (-s currently works as well)
     --tz               show time zone

  Also see: dat, date_

  ($email_full)
";
exit (@_ ? 1 : 0);
}

my $opt_sec = 0;
my $opt_day = 0;
my $opt_tz;

my $t;

while (@ARGV) {
    my $v = shift @ARGV;
    if ($v eq "-s" or $v eq "--sec" or $v eq "--seconds") {
        $opt_sec = 1;
        $opt_day = 0;
    }
    elsif ($v eq "--day") {
        $opt_sec = 0;
        $opt_day = 1;
    }
    elsif ($v eq "--tz") {
        $opt_tz = 1;
    }
    elsif ($v eq "-h" or $v eq "--help") {
        usage
    }
    else {
        if (defined $t) {
            usage "unknown argument '$v'";
        } else {
            $v=~ /^\d+\z/
                or usage("invalid time argument '$v', must be unixtime ".
                         "(seconds since epoch)");
            $t = $v;
        }
    }
}

usage if @ARGV; # needed? see algo above

$t //= time;

my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime($t)
    or die "invalid time";

my $MIN = $opt_day ? '' : '_%02d%02d';
my $SEC = $opt_sec ? '%02d' : '';
my $TZ = $opt_tz ? do {
    require DateTime;
    require DateTime::TimeZone;
    my $tz = DateTime::TimeZone->new(name=> "local");
    my $dt = DateTime->from_epoch(epoch=> $t);
    "_" . $tz->short_name_for_datetime( $dt )
} : '';

printf("%04d-%02d-%02d$MIN$SEC$TZ\n",
       $year+1900, $mon+1, $mday,
       ($opt_day ? () :
        ($hour, $min, ($opt_sec ? $sec : ()))))
    or die "stdout: $!";

#use FP::Repl; repl;
