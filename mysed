#!/usr/bin/perl -w

use constant DEBUG => 0;
my $name= "mysed";
use strict; use warnings FATAL => 'uninitialized';

use Fcntl;
use File::Path;
use POSIX 'EXDEV';
use Chj::xperlfunc 'xstat','xlstat','xutime','xxsystem';

sub usage {
    warn @_,"\n" if @_;
    print "$name s/../../sigo -r . [ '\\.html?\$' ]\n";
    print "$name s/../../sigo file1 file2 file3 ...\n";
    print "$name s/../../sigo -T filelist\n";
    print "$name s/../../sigo -l < filelist\n";
    print "  Applies perl regex to all given files; moves old versions of the modified\n";
    print "  files to the trash can (if possible).\n";
    print "  Other options: (to be given after the code argument, too, \n";
    print "                 *but before* the above-mentioned options!)\n";
    print "    --keep-time    keep the modification time of the file\n";
    print "                   (if it's a symlink, hmmmm currently get the mtime of the\n";
    print "                   pointed-at file and apply it to the new file which replaces\n";
    print "                   the symlink, right? todo: check or improve?)\n";
    print "    --no-trash     just replace old file versions instead of moving them to trash\n";
    print "    --quiet|-q     do not print messages about changes that have been done\n";
    exit (@_ ? 1 : 0);
}


my $regex=shift or usage;
my $mode;
# f=filelist in @ARGV,
# -=filelist on stdin,
# r=recursive with $path and $optionalpathregex

my ($path,
    $optionalpathregex,
    $fileregex_is_negative,
    $opt_keep_time,
    $opt_no_trash,
    $opt_quiet);

OPTPARSE: {
    local $_= $ARGV[0]; defined or usage;
    if ($_ eq '-r') {
	$mode='r';
	shift;
	$path=shift
	  or usage "missing path";
	$optionalpathregex= shift;
	# Special character ! at beginning has special meaning
	$fileregex_is_negative=1
	  if $optionalpathregex and $optionalpathregex=~ s/^\!//s;
    } elsif ($_ eq '-l') {
	$mode='-';
	shift;
    } elsif ($_ eq '-T') { # same as tar's -T option
	defined($ARGV[1]) && length($ARGV[1])
	  or usage "missing argument for -T";
	open STDIN, "<$ARGV[1]"
	  or die "opening '$ARGV[1]' for input: $!";
	$mode='-';
	shift;
    } elsif ($_ eq '--keep-time') {
	$opt_keep_time=1;
	shift;
	redo OPTPARSE;
    } elsif ($_ eq '--no-trash') {
	$opt_no_trash=1;
	shift;
	redo OPTPARSE;
    } elsif ($_ eq '-q' or $_ eq '--quiet') {
	$opt_quiet=1;
	shift;
	redo OPTPARSE;
    } elsif ($_ eq '--') {
	# ignore
	shift;
	$mode='f';
    } else {
	$mode='f';
    }
}


eval "sub doreg { $regex }; 1"
  or die "could not eval regex: $@";

use Chj::App::Trash;

our $trash= do {
    if ($opt_no_trash) {
	undef
    } else {
	Chj::App::Trash->new->trashdir
	    # XXX only works as long as I don't change the trasher to
	    # per-partition mechanism. Would have to change here.
    }
};

if ($trash and $mode eq 'r')
  # more problems: symlinks?, mount --bind?, mount within tree,
  # XXX: test for EXDEV, ask
 {
    my $trashdev= (stat $trash)[0]; ## or die?
    my $pathdev= (stat $path)[0];
    defined $pathdev or die "could not stat '$path': $!";
    ASK: {
	my $ans;
	do {
	    #print STDERR "Na: $trashdev , $pathdev\n";
	    if (!defined $trashdev) {
		print STDERR "Your trash could not be stat'ed: $!. Do you want to do without trash? [y/n] ";
	    } elsif ( $trashdev != $pathdev) {
		print STDERR "Your trash is not on the same partition as the directory.  Do you want to do without trash? [y/n] ";
	    } else {
		last ASK
	    }
	    $ans=<STDIN>;
	} until ($ans=~ /^y/i or $ans=~ /^n/i and die "user cancelled.\n");
	$trash=undef; # ugly
    }
}

my $appendix= "".localtime();
$appendix=~ s/ /_/sg;

my $actualtrashdir= "$trash/$name/$appendix"
  if $trash;


sub scandir {
    my ($dir)=@_;
    warn "Scanning dir $dir\n" if DEBUG;
    if (opendir DIR,$dir) {
        my $item;
        my @items= readdir DIR;
        closedir DIR;
        for $item (@items) {
            next if $item eq '.' or $item eq '..';
            if (-d "$dir/$item") {
                #warn "Found dir: $item\n" if DEBUG;
                if (-l "$dir/$item") {
                    warn "Ignoring directory link `$dir/$item'\n";
                } else {
                    scandir ("$dir/$item");
                }
            } elsif (-f _) {
                if (defined $optionalpathregex) {
                    if ("$dir/$item"=~ /$optionalpathregex/os) {
                        warn "File $dir/$item matches '$optionalpathregex'\n"
			  if DEBUG;
                        next if $fileregex_is_negative;
                    } else {
                        warn "File $dir/$item does NOT match '$optionalpathregex'\n"
			  if DEBUG;
                        next unless $fileregex_is_negative;
                    }
                }
                #warn "Found file: $item\n" if DEBUG;
                changefile ($dir,$item);
            } else {
                warn "Special file $dir/$item\n";
            }
        }
    } else {
        warn "could not open dir '$dir': $!\n";
    }
}

my $opt_L;

sub changefile {
    my ($folder,$file)=@_;
    my $path= length($folder)? "$folder/$file" : $file;##hum?
    my $maybe_stat= ($opt_keep_time and xstat $path);
    my $is_exe= -x $path;
    my $maybe_apply_statinfo= sub {
	if ($maybe_stat) {
	    # lstat here, since we will apply to whatever is *here* anyway, ok?
	    my $newstat= xlstat $path;
	    xutime $newstat->atime, $maybe_stat->mtime,  $path;
	}
	if ($is_exe) {
	    # how inelegant? but xstat objects don't have functional
	    # setters (and updating methods) (it doesn't even have a
	    # -x method!).
	    xxsystem "chmod","+x","--",$path;
	}
    };
    warn "Scanning file $path\n" if DEBUG;
    if (open FILE ,"<$path") {
        local $/=undef;
        local $_=<FILE>;
        close FILE;
        if (my $cnt = doreg()) {
            print "$cnt ".($cnt==1 ? "change": "changes")." in $path\n"
	      unless $opt_quiet;
            if (sysopen OUT, "$path.$appendix",O_EXCL|O_CREAT|O_WRONLY) {
                my $r=syswrite OUT,$_;
                if (defined $r and $r==length($_)) {
                    close OUT;
		    #(should be placed above, but that would clobber $!)
		  CHANGE:{
			if ($trash) {
			    my $trashpath= $folder;
			    $trashpath=~ s|^../|__/|s;
			    $trashpath=~ s|/../|/__/|sg;##todo is wrong right
			    $trashpath=~ s|/..$|/__|s;
			    $trashpath= "$actualtrashdir/$trashpath";
			    mkpath($trashpath); # error check?
			    if (rename $path,"$trashpath/$file") {
				# ok
			    } elsif ($!==EXDEV) {
				if ($opt_L) {
				    unlink "$path.$appendix";
				    last CHANGE;
				}
			      ASK:{
				    print STDERR "'$path' could not be moved to '$trashpath/$file', because they are not on the same filesystem. What should I do: [l]eave file unchanged, [L]eave always without asking, [o]verwrite old file without backup, [O]verwrite always without asking ? ";
				    my $ans=<STDIN>;chomp $ans;
				    if ($ans eq 'l') {
					unlink "$path.$appendix";
					last CHANGE;
				    } elsif ($ans eq 'L') {
					unlink "$path.$appendix";
					$opt_L=1;
					last CHANGE;
				    } elsif ($ans eq 'o') {
					last ASK;
				    } elsif ($ans eq 'O') {
					undef $trash;##todo bad, not really same as L handling, i.e. if getting back to region in subtree where it *is* on same filesystem, this is 'gone.
					last ASK;
				    } else {
					redo ASK;
				    }
				}#/ASK
			    } else {
				die "Could not move `$path' to trash dir `$trashpath/$file': $!";
			    }
			}
			if (rename "$path.$appendix",$path) {
			    &$maybe_apply_statinfo;
			    # OK!
			} else {
			    die "Could not rename `$path.$appendix' to `$path': $!";
			}
		    }#/CHANGE
                } else {
                    die "Could not write (everything) to file `$folder/$file.$appendix': $!";
                }
            } else {
                die "Could not open file `$folder/$file.$appendix' for writing: $!";
            }
        } else {
            warn "No match in $path\n" if DEBUG;
        }
    } else {
        warn "Could not open file '$path': $!\n";
    }
}


#warn "mode=$mode";

if ($mode eq 'r') {
    if (-d $path) {
	scandir($path);
    } else {
	$path=~ m|(.*?)([^/]+)$|s or die "???";
	my ($folder,$file)=($1,$2);
	$folder=~ s/\/$//s;
	changefile($folder,$file);
    }
}
elsif ($mode eq '-') {
    while (<STDIN>) {
	chomp;
	m|(.*?)([^/]+)$|s or die "???";
	my ($folder,$file)=($1,$2);
	$folder=~ s/\/$//s;
	changefile($folder,$file);
    }
}
elsif ($mode eq 'f') {
    for (@ARGV) {
	m|(.*?)([^/]+)$|s or die "???";
	my ($folder,$file)=($1,$2);
	$folder=~ s/\/$//s;
	changefile($folder,$file);
    }
}
else {
    die "?? mode=$mode";
}

