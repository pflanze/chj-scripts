#!/usr/bin/perl -w

# Wed Dec 23 18:38:22 CET 2009
# Released into the public domain

(my $email='chrjae%gmail,com')=~ tr/%,/@./;

use strict;

our $timeout_untrusted=60;
our $timeout_trusted=0;

$0=~ /(.*?)([^\/]+)\z/s or die "?";
my ($mydir, $myname)=($1,$2);
sub usage {
    print STDERR map{"$_\n"} @_ if @_;
    print "$myname chrootbase user [ -- cmd [arguments] ]

  Options:
  -X  give access to X server
  --untrusted  give untrusted X connection only (default: trusted)
  --timeout n  timeout for the X authority
               (instead of $timeout_trusted or $timeout_untrusted for trusted/untrusted)
  -c 'code'  pass as -c option to su
  --builtin --uid uid --gid gid --gids gid,..
             use Perl code to do the chroot and setgid/setuid calls
             instead of relying on the 'chroot' and 'su' (the latter
             from inside the chroot) tools (but the -X option does the
             same, too). This *might* be safer for untrusted chroots
             (modulo oversights and perhaps the perl interpreter
             accessing the chroot implicitely).  In this case the
             'user' argument is only used to set the USER and USERNAME
             env vars. No lookup in the passwd database is done. HOME
             is set to \"/home/\$USERNAME\".

  (Christian Jaeger <$email>)
";
exit (@_ ? 1 : 0);
}

use Getopt::Long;
our $verbose=0;
#our $opt_dry;
our $opt_X;
our $opt_untrusted;
our $opt_timeout;
our $opt_c;
our ($opt_builtin, $opt_uid,$opt_gid,$opt_gids,@opt_gids);
GetOptions("verbose"=> \$verbose,
	   "help"=> sub{usage},
	   #"dry-run"=> \$opt_dry,
	   "X"=> \$opt_X,
	   "untrusted"=>\$opt_untrusted,
	   "timeout=n"=>\$opt_timeout,
	   "c=s"=>\$opt_c,
	   "builtin"=>\$opt_builtin,
	   "uid=n"=>\$opt_uid,
	   "gid=n"=>\$opt_gid,
	   "gids=s"=> sub {
	       my ($_name, $str)=@_;
	       defined $opt_gids
		 and usage "multiple --gids options given";
	       $opt_gids= $str;
	       @opt_gids= map {
		   /^(\d+)\z/
		     or usage "invalid --gids option, must be ".
		       "comma-separated non-negative integers, got '$_'";
		   $1
	       } split /,/, $str;
	   },
	  ) or exit 1;
usage unless @ARGV>=2;

our ($chrootbase,$user,@cmd)= @ARGV;

if ($opt_builtin) {
    usage "missing --uid while --builtin is given" unless defined $opt_uid;
    usage "missing --gid while --builtin is given" unless defined $opt_gid;
    usage "missing --gids while --builtin is given" unless defined $opt_gids;
    usage "option -c not accepted with --builtin; pass cmd and args as individual arguments instead"
      if $opt_c;
    @cmd or usage "missing cmd and args";
} else {
    usage "missing --builtin while one of --uid --gid --gids was given"
      if (defined $opt_uid or defined $opt_gid or defined $opt_gids);
}

if ($opt_c and @cmd) {
    usage "both cmd and -c given"
}


# XXX: this is a *BAD* way to implement passing @cmd, but I don't know how
# else to do it currently:
use Chj::singlequote 'singlequote_sh';
if (@cmd) {
    $opt_c = join(" ",map { singlequote_sh $_ } @cmd);
}

use Chj::xperlfunc;
use Chj::xopen 'xopen_read';
use Chj::xtmpfile;
use Chj::xtmpdir;
use Chj::IO::Command;

my $maybe_display= $ENV{DISPLAY};
my $X= ($opt_X and $maybe_display);

use Chj::Trace;

my $Xauth= do {
    if ($X) {
	my $display= $maybe_display;
	my $d= xtmpdir;
	{
	    my $t= xtmpfile "$d/something";
	    xxsystem
	      ( "xauth","-f",$t->path,"generate",$display,".",
		($opt_untrusted ? "untrusted" : "trusted"),
		"timeout", (defined($opt_timeout) ? $opt_timeout :
			    ($opt_untrusted ? $timeout_untrusted : $timeout_trusted)),
	      );
	    # this replaced "$t", but we don't bother. Still, we
	    # rely on $t not going out of scope yet
	    my $t2= Chj::IO::Command->new_sender
	      ("xauth","-f", $t->path,# "$t" does *not* work, unlike "$d"
	       "nextract", "-", $display);#hm DISPLAY for what's inside the file now.. still same?
	    my $cnt=$t2->xcontent;
	    $t2->xxfinish;
	    #print "extracted: '$cnt'\n";#
	    $cnt
	}
    } else {
	undef
    }
};

use Chj::Unix::Mount 'mount_if_not_already','mounted','mount';
use Chj::Path::Expand ':all';

mount_if_not_already qw(-t proc proc), "$chrootbase/proc";
mount_if_not_already qw(-t usbfs usbfs), "$chrootbase/proc/bus/usb";

mount_if_not_already qw(-t sysfs sysfs), "$chrootbase/sys";

my $devfs_is_initialized= mounted "$chrootbase/dev";

if (not $devfs_is_initialized) {
    mount "--bind", "/dev", "$chrootbase/dev";
    mount "--bind", "/dev/pts", "$chrootbase/dev/pts";
}

mount_if_not_already qw(-t tmpfs -o), 'nosuid,relatime,mode=755',
  "tmpfs","$chrootbase/lib/init/rw";

if (-l "$chrootbase/dev/shm") {
    my $target= PathExpand_all("/dev/shm", $chrootbase);
    #warn "target='$target'";
    mount_if_not_already qw(-t tmpfs -o), 'nosuid,relatime,mode=1777',
      "tmpfs",$target;
} else {
    mount_if_not_already qw(-t tmpfs -o), 'nosuid,relatime,mode=1777',
      "tmpfs","$chrootbase/dev/shm";
}

# force libraries for getpwnam to be loaded from the host context
{
    my
      ($name,$passwd,$uid,$gid,
       $quota,$comment,$gcos,$dir,$shell,$expire) = getpwnam $user;
    #or warn "note: could not look up user on host: '$user'";
}


if ($X) {
    if (xfork) {
	xxwait;
    } else {
	xchroot $chrootbase;
	my
	  ($name,$passwd,$uid,$gid,
	   $quota,$comment,$gcos,$dir,$shell,$expire) = getpwnam $user
	     or die "could not look up user '$user'";
	xchdir $dir;
	$ENV{HOME}=$dir;
	$ENV{USER}=$name;
	$ENV{USERNAME}=$name;
	#$ENV{LOGNAME}=$name;
	# ^ ps all this code again?.... see Chj::Unix::Su or so.
	delete $ENV{XAUTHORITY}; #oh yes
	$( = $gid; $) = $gid;
	$< = $uid; $> = $uid;
	#or die? how ?  and  does it delete the secondary groups?
	if ($X) {
	    my $f= Chj::IO::Command->new_receiver
	      ("xauth",
	       # with default .Xauthority file location
	       "nmerge", "-");
	    $f->xprint($Xauth);
	    $f->xxfinish;
	}
	exit 0;
    }

} else {

    if ($opt_builtin) {
	# Partial COPY from $X variant above!
	# But don't trust the chroot
	my $home= "/home/$user";
	xchroot $chrootbase;
	chdir $home or do {
	    # ugly but accessing $! would access files, right?
	    print STDERR "could not chdir to '$home' within the chroot\n";
	    exit 1;
	};
	$ENV{HOME}=$home;
	$ENV{USER}=$user;
	$ENV{USERNAME}=$user;
	#$ENV{LOGNAME}=$name;
	# ^ ps all this code again?.... see Chj::Unix::Su or so.
	delete $ENV{XAUTHORITY}; #oh yes
	$( = $opt_gid; $) = join " ", $opt_gid, @opt_gids;
	$< = $opt_uid; $> = $opt_uid;
	#or die? how ?

	-x $cmd[0] or do {
	    print STDERR "can't access executable at '$cmd[0]'\n";
	    exit 127; # correct code?
	};
	
	local $^W; # prevent perl from looking up $!, needed?
	exec @cmd or do {
	    print STDERR "could not execute '$cmd[0]'\n";
	    exit 127; # correct code?
	}
    } else {
	xexec "chroot", $chrootbase, "su", "-", $user,
	  ($opt_c ? ("-c", $opt_c) : ());
    }

}

#use Chj::ruse;
#use Chj::Backtrace; use Chj::repl; repl;
