#!/usr/bin/perl -w

my $copyright= <<'COPYRIGHT';
# Copyright 2021 by Christian Jaeger <ch@christianjaeger.ch>
# Published under the same terms as perl itself
COPYRIGHT

use strict; 
use warnings FATAL => 'uninitialized';
use experimental 'signatures';

my ($email_full)= $copyright=~ / by ([^\n]*)/s;

my ($mydir, $myname);
BEGIN {
    $0=~ /(.*?)([^\/]+)\z/s or die "?";
    ($mydir, $myname)=($1,$2);
}

sub usage {
    print STDERR map{"$_\n"} @_ if @_;
    print "$myname [ path-from-git-root... ]

  Print Git web UI URLs to see the given files. By default, looks in
  'origin' and 'github' for github base URLs. If no path is given,
  show the repository home URL.

  Options:

    --base url        base Github URL to use instead of auto-detection
    --no-assert       do not verify we're in the root of a Git checkout
    --current-commit  use the current commit instead of the branch name
    --commit commit   give URL to show the diff for the given change
    --commits c1 c2   give URL to show the changeset for the given commits

  ($email_full)
";
exit (@_ ? 1 : 0);
}


use Getopt::Long;
our $verbose=0;
my $opt_base;
my $opt_noassert;
my $opt_current_commit;
my $opt_commit;
my $opt_commits;
#our $opt_dry;
GetOptions("verbose"=> \$verbose,
	   "help"=> sub{usage},
           "base=s"=> \$opt_base,
           "no-assert"=> \$opt_noassert,
           "current-commit" => \$opt_current_commit,
           "commit" => \$opt_commit,
           "commits" => \$opt_commits,
	   #"dry-run"=> \$opt_dry,
	   ) or exit 1;

sub _auto_detect_remote {
    my $remotes= `git remote -v`; $? == 0 or die "git remote exited $?";

    my @remotes= map {
        my @s= split /\t/, $_;
        @s == 2 or die "parsing issue, execting 2 fields, got: @s";
        my ($name, $rest)= @s;
        my @s2= split /\s+/, $rest;
        @s2 >= 2 or die "parsing issue, expecting >= 2 fields, got: @s2";
        my ($url, $mode)= @s2;
        [ $name, $url, $mode ]
    } split /\n/, $remotes;

    my @r = grep {
        my ($name, $url, $mode)= @$_;
        ($name eq "origin" or $name eq "github")
            and $url=~ /github\.com/
    } @remotes;

    my @r_https= grep  {
        my ($name, $url, $mode)= @$_;
        $url=~ /^https:/;
    } @r;
    my @r_ssh= grep  {
        my ($name, $url, $mode)= @$_;
        $url=~ /^\w+\@\w+/;
    } @r;

    if (@r) {
        if (@r_https) {
            $r_https[0][1]
        } elsif (@r_ssh) {
            my $r = $r_ssh[0][1];
            my ($uname, $dom, $rest) = $r=~ /^(\w+)\@([^:]+):(.*)/s
                or die "can't parse this purported ssh location: '$r'";
            $uname eq "git"
                or die "username in ssh location is not 'git': '$r'";
            "https://$dom/$rest"
        } else {
            die "missing https or ssh location";
        }
    } else {
        die "$myname: none of the remotes in the current repository is named origin or github and refers to a github url\n";
    }
}

sub auto_detect_remote () {
    my $url= _auto_detect_remote;
    $url=~ s/\.git.*//;
    $url
}


my $base= $opt_base // auto_detect_remote;

sub github_url_for_path ($path, $revision) {
    # -> https://github.com/pflanze/chj-bin/blob/master/0or1
    if ($path=~ m{^/}) {
        die "path is absolute, expecting relative from Git root: '$path'"
    }
    $path=~ s{^\./+}{}s;
    $path=~ s{/+}{/}sg;
    "$base/blob/$revision/$path"
}

sub whichgit() {
    my $cmd= quotemeta($mydir)."/whichgit";
    my $p= `$cmd`; $? == 0 or die "whichgit exited with $? (maybe you are not inside a Git checkout?)";
    chomp $p;
    $p
}

unless ($opt_noassert) {
    my $whichgit= whichgit;
    $whichgit eq ".git" or die "$myname: you don't appear to be in the root of a Git checkout, as we're expecting whichgit to be at .git but it's at: '$whichgit'\n";
}

sub git($dangerous_shell_code) {
    my $s = `git $dangerous_shell_code`;
    $? == 0 or die "error running git $dangerous_shell_code";
    chomp $s;
    $s
}

sub current_commitid() {
    git "rev-parse HEAD"
}

sub current_branch() {
    git "rev-parse --abbrev-ref HEAD"
}

if (!@ARGV) {
    print "$base\n" or die $!;

} elsif ($opt_commits) {
    if (@ARGV != 2) {
        usage "need 2 arguments for --commits"
    }
    my ($start, $end) = @ARGV;
    print "$base/compare/$start...$end\n";

} elsif ($opt_commit) {
    if (@ARGV != 1) {
        usage "need 1 argument for --commit"
    }
    my ($commit) = @ARGV;
    print "$base/commit/$commit\n";

} else {
    my $revision = $opt_current_commit ? current_commitid : current_branch;

    for (@ARGV) {
        my $url= github_url_for_path $_, $revision;
        print "$url\n" or die $!;
    }
}

#use FP::Repl; repl;
#use Chj::ruse;
#use Chj::Backtrace; 

